import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth, useSpecialty, getSpecialtyRoute } from '../../stores/useAppStore';
import { supabase } from '../../lib/supabase';

// This component handles redirects from the root path and auth tokens
export const RootRedirect: React.FC = () => {
  const { user } = useAuth();
  const { specialty, isSpecialtyVerified, isLoading } = useSpecialty();
  const navigate = useNavigate();
  const [authProcessed, setAuthProcessed] = useState(false);

  // Check for auth tokens immediately on mount
  useEffect(() => {
    const checkAuthTokens = () => {
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const accessToken = hashParams.get('access_token');
      const refreshToken = hashParams.get('refresh_token');
      const type = hashParams.get('type');
      const error = hashParams.get('error');

      console.log('üîç RootRedirect: Checking for auth tokens:', {
        hasAccessToken: !!accessToken,
        hasRefreshToken: !!refreshToken,
        type,
        error,
        fullHash: window.location.hash
      });

      // If we have auth tokens, process them immediately
      if (accessToken || refreshToken || type || error) {
        console.log('‚úÖ RootRedirect: Auth tokens detected, will process');
        return true;
      }
      console.log('‚ùå RootRedirect: No auth tokens found');
      return false;
    };

    const hasAuthTokens = checkAuthTokens();
    if (!hasAuthTokens) {
      setAuthProcessed(true);
    }
  }, []);

  // Handle auth tokens if they exist
  useEffect(() => {
    const handleAuthTokens = async () => {
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const accessToken = hashParams.get('access_token');
      const refreshToken = hashParams.get('refresh_token');
      const type = hashParams.get('type');
      const error = hashParams.get('error');
      const errorDescription = hashParams.get('error_description');

      // Skip if no auth tokens
      if (!accessToken && !refreshToken && !type && !error) {
        return;
      }

      // Handle auth errors
      if (error) {
        console.error('Auth error:', error, errorDescription);
        navigate('/signin?error=' + encodeURIComponent(errorDescription || error), { replace: true });
        return;
      }

      // Handle password recovery
      if (type === 'recovery' && accessToken && refreshToken) {
        console.log('üîÑ RootRedirect: Processing password recovery tokens');
        try {
          const { data: { session }, error } = await supabase.auth.setSession({
            access_token: accessToken,
            refresh_token: refreshToken
          });

          if (error) {
            console.error('‚ùå RootRedirect: Error setting session for password reset:', error);
            navigate('/forgot-password?error=' + encodeURIComponent('Invalid or expired reset link'), { replace: true });
            return;
          }

          if (session) {
            console.log('‚úÖ RootRedirect: Session set successfully, redirecting to reset-password');
            // Clear the URL hash for security
            window.history.replaceState({}, document.title, window.location.pathname);
            // Redirect to reset password form
            navigate('/reset-password', { replace: true });
            return;
          }
        } catch (err) {
          console.error('‚ùå RootRedirect: Failed to process reset token:', err);
          navigate('/forgot-password?error=' + encodeURIComponent('Failed to process reset link'), { replace: true });
          return;
        }
      }

      // Handle email confirmation
      if (type === 'signup' && accessToken && refreshToken) {
        try {
          const { data: { session }, error } = await supabase.auth.setSession({
            access_token: accessToken,
            refresh_token: refreshToken
          });

          if (error) {
            console.error('Error confirming email:', error);
            navigate('/signin?error=' + encodeURIComponent('Email confirmation failed'), { replace: true });
            return;
          }

          if (session) {
            // Clear the URL hash for security
            window.history.replaceState({}, document.title, window.location.pathname);
            // Redirect to onboarding
            navigate('/onboarding', { replace: true });
            return;
          }
        } catch (err) {
          console.error('Failed to confirm email:', err);
          navigate('/signin?error=' + encodeURIComponent('Email confirmation failed'), { replace: true });
          return;
        }
      }

      setAuthProcessed(true);
    };

    handleAuthTokens();
  }, [navigate]);

  // Normal redirect logic - only runs after auth processing is done
  useEffect(() => {
    console.log('üè† RootRedirect: Normal redirect logic:', {
      authProcessed,
      hasUser: !!user,
      isLoading,
      specialty,
      isSpecialtyVerified
    });

    if (!authProcessed || !user || isLoading) {
      console.log('‚è≥ RootRedirect: Waiting - authProcessed:', authProcessed, 'user:', !!user, 'isLoading:', isLoading);
      return;
    }

    // If user has a specialty, redirect to their workspace
    if (specialty && isSpecialtyVerified) {
      const specialtyRoute = getSpecialtyRoute(specialty);
      console.log('üè• RootRedirect: Redirecting to workspace:', specialtyRoute);
      navigate(specialtyRoute, { replace: true });
    }
  }, [authProcessed, user, specialty, isSpecialtyVerified, isLoading, navigate]);

  // Show loading while determining where to redirect
  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
        <p className="text-gray-600">Loading...</p>
      </div>
    </div>
  );
};